---
title: "AutoCAD面域转多段线"
publishDate: 2022-08-29 00:26:00 +0800
date: 2022-08-29 00:14:08 +0800
categories: AutoCAD windows dotnet csharp
position: problem
---

AutoCAD面域转多段线

---

<div id="toc"></div>

## 问题

AutoCAD2014版本没有面域转为多段线的直接方法，需要自己实现。

## 解决

主要逻辑，通过Brep获取到面域的边界线，再根据边界线重新生成多段线，把曲线（Arc）转为多段线时bulge的计算方法。

```c#
/// <summary>
/// 面域转为多段线
/// </summary>
/// <param name="region"></param>
/// <returns></returns>
public static Polyline ToPolylines(this Region region)
{
    Polyline pl = new Polyline();
    var brep = new Brep(region);
    var edges = brep.Edges.ToList();
    var list = new List<Curve>();
    //获取边界线
    foreach (var edge in edges)
    {
        var eCurve = (ExternalCurve3d)edge.Curve;

        if (eCurve.IsCircularArc || eCurve.IsLineSegment)
        {
            var curve = Polyline.CreateFromGeCurve(eCurve.NativeCurve);
            list.Add(curve);
            //var angle = arc.EndAngle - arc.StartAngle;
            //if (angle < 0)
            //    angle += Math.PI * 2.0;
            //double bulge = Math.Tan(angle / 4.0);
        }
    }
    //获取到的边界可能不是第二条线的起点对应第一条线的终点，而是第一条线的起点对应第二条线的终点，线的顺序是反向，
    //这里重新排序，保证边界线是顺序相接的
    if (list.Count > 1 && list[0].StartPoint == list[1].EndPoint)
    {
        list.Reverse();
    }
    //重新绘制多段线
    foreach (var curve in list)
    {
        if (curve is Line)
        {
            if (pl.NumberOfVertices == 0)
            {
                pl.AddVertexAt(pl.NumberOfVertices, curve.StartPoint.ToPoint2d(), 0, 0, 0);
            }
            pl.AddVertexAt(pl.NumberOfVertices, curve.EndPoint.ToPoint2d(), 0, 0, 0);
        }
        else if (curve is Arc)
        {
            var arc = curve as Arc;
            var diffAngle = arc.EndAngle - arc.StartAngle;
            double bulge;
            if (diffAngle < 0)
            {
                diffAngle += 2 * Math.PI;
                bulge = Math.Tan(diffAngle / 4) * -1;
            }
            else
            {
                bulge = Math.Tan(diffAngle / 4);
            }
            //弧线要根据正向或反向弧计算bulge
            bulge *= arc.Normal.Z;
            if (bulge != 0)
            {
                if (pl.NumberOfVertices != 0)
                {
                    pl.RemoveVertexAt(pl.NumberOfVertices - 1);
                }
                pl.AddVertexAt(pl.NumberOfVertices, curve.StartPoint.ToPoint2d(), bulge, 0, 0);
            }
            pl.AddVertexAt(pl.NumberOfVertices, curve.EndPoint.ToPoint2d(), 0, 0, 0);
        }
    }
    return pl;
}
```

---

**参考资料**
