<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://dashenxian.github.io/</id><title>dashenxian</title><subtitle>小神仙的博客。.NET/C#/Winform/ASP.Net/AutoCAD 应用开发者。</subtitle> <updated>2024-11-16T20:51:44+08:00</updated> <author> <name>小神仙</name> <uri>https://dashenxian.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://dashenxian.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://dashenxian.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2014-2024 dashenxian </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>添加自己得docker加速镜像</title><link href="https://dashenxian.github.io/post/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E5%BE%97docker%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F" rel="alternate" type="text/html" title="添加自己得docker加速镜像" /><published>2024-11-16T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E5%BE%97docker%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F</id> <content src="https://dashenxian.github.io/post/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E5%BE%97docker%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F" /> <author> <name>小神仙</name> </author> <category term="docker" /> <category term="ubantu" /> <category term="snap" /> <summary> 上一篇博文讲到了docker如何添加加速镜像，但是加速镜像地址是用的别人的，这里我们来注册自己的加速镜像地址 注册账号 注册cloudflare账号 部署脚本 左侧菜单中 Workers 和 Pages –&amp;gt; 概述 –&amp;gt; 创建 创建worker 修改名称，也可用默认的名称，点击部署 点编辑代码 复制以下代码到worker.js编辑窗口中,注意1中的域名可以直接填写2处的域名，也可以是你自己的域名，你自己的域名必须是通过cloudflare解析的 // _worker.js // Docker镜像仓库主机地址 let hub_host = 'registry-1.docker.io'; // Docker认证服务器地址 const auth_url = 'htt... </summary> </entry> <entry><title>snap 安装的docker，如何添加加速镜像和重启服务</title><link href="https://dashenxian.github.io/post/snap-%E5%AE%89%E8%A3%85%E7%9A%84docker-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F%E5%92%8C%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1" rel="alternate" type="text/html" title="snap 安装的docker，如何添加加速镜像和重启服务" /><published>2024-10-22T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/snap-%E5%AE%89%E8%A3%85%E7%9A%84docker-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F%E5%92%8C%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1</id> <content src="https://dashenxian.github.io/post/snap-%E5%AE%89%E8%A3%85%E7%9A%84docker-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F%E5%92%8C%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1" /> <author> <name>小神仙</name> </author> <category term="docker" /> <category term="ubantu" /> <category term="snap" /> <summary> 在我们这里无法拉取docker镜像，一般可以通过设置国内镜像源/加速列表来拉取镜像，但是ubantu22开始建议用snap来安装docker，如果用snap安装镜像后，你会发现搜到的各种设置后还是拉取不了，因为snap安装的docker根本不读取那个配置了 通过 snap 安装的 Docker 需要特别的步骤来配置镜像地址。以下是具体的步骤： 创建 Docker 配置文件目录 Snap 安装的 Docker 可能没有默认的配置文件目录，需要手动创建。 sudo mkdir -p /var/snap/docker/current/config 创建并编辑配置文件 在 /var/snap/docker/current/config 目录下创建 daemon.json 文件，并添加你的镜像地址。 sudo vim /var/snap/docker/current/con... </summary> </entry> <entry><title>Powershell增强：命令补全</title><link href="https://dashenxian.github.io/post/Powershell%E5%A2%9E%E5%BC%BA-%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%A8" rel="alternate" type="text/html" title="Powershell增强：命令补全" /><published>2024-02-23T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/Powershell%E5%A2%9E%E5%BC%BA-%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%A8</id> <content src="https://dashenxian.github.io/post/Powershell%E5%A2%9E%E5%BC%BA-%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%A8" /> <author> <name>小神仙</name> </author> <category term="windows" /> <category term="Powershell" /> <summary> 安装插件 安装 PSReadLine PSReadLine 提供了语法高亮、错误提示、多行编辑、键绑定、历史记录搜索等功能： Install-Module PSReadLine 安装 posh-git posh-git 可以在 PowerShell 中显示 Git 状态信息，并提供 Git 命令的自动补全： Install-Module posh-git 配置插件 自定义配置 执行以下命令，第一次会显示找不到该文件，选择创建新文件： notepad $profile 作用是在 PowerShell 启动时运行一些自定义的设置，比如导入模块、设置别名、定义函数等。 粘贴以下配置内容，可以参考注释根据自己需求修改或者删除： #------------------------------- Import Modules BEGIN ---------... </summary> </entry> <entry><title>net6之后读取response.body方式</title><link href="https://dashenxian.github.io/post/net6%E4%B9%8B%E5%90%8E%E8%AF%BB%E5%8F%96response.body%E6%96%B9%E5%BC%8F" rel="alternate" type="text/html" title="net6之后读取response.body方式" /><published>2024-02-01T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/net6%E4%B9%8B%E5%90%8E%E8%AF%BB%E5%8F%96response.body%E6%96%B9%E5%BC%8F</id> <content src="https://dashenxian.github.io/post/net6%E4%B9%8B%E5%90%8E%E8%AF%BB%E5%8F%96response.body%E6%96%B9%E5%BC%8F" /> <author> <name>小神仙</name> </author> <category term="asp.net" /> <category term="core" /> <category term="dotnet" /> <category term="csharp" /> <summary> asp.net core 3.1的时候可以直接通过StreamReader读取HttpContext.Response.Body，此方式在更新到.net6后不再可行。 问题 asp.net core 3.1的时候可以直接通过StreamReader读取HttpContext.Response.Body，此方式在更新到.net6后不再可行。调试发现HttpContext.Response.Body的CanRead属性是false，是一个可写不可读的流。 解决 .ne6之后要读取body必须用一个内存流替换原来的流，读取完成后再替换回去。以下示例代码是在中间件中写的： using (var memoryStream = new MemoryStream()) { context.Response.Body = memoryStream; await _n... </summary> </entry> <entry><title>net6之后不能通过替换HttpContext.Request.Path实现转发到其他路由</title><link href="https://dashenxian.github.io/post/net6%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2HttpContext.Request.Path%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%8F%91%E5%88%B0%E5%85%B6%E4%BB%96%E8%B7%AF%E7%94%B1" rel="alternate" type="text/html" title="net6之后不能通过替换HttpContext.Request.Path实现转发到其他路由" /><published>2024-02-01T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/net6%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2HttpContext.Request.Path%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%8F%91%E5%88%B0%E5%85%B6%E4%BB%96%E8%B7%AF%E7%94%B1</id> <content src="https://dashenxian.github.io/post/net6%E4%B9%8B%E5%90%8E%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2HttpContext.Request.Path%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%8F%91%E5%88%B0%E5%85%B6%E4%BB%96%E8%B7%AF%E7%94%B1" /> <author> <name>小神仙</name> </author> <category term="asp.net" /> <category term="core" /> <category term="dotnet" /> <category term="csharp" /> <summary> asp.net core 3.1的时候可以直接通过替换HttpContext.Request.Path实现转发到其他路由，此方式在更新到.net6后默认不再可行。 问题 asp.net core 3.1的时候可以直接通过替换HttpContext.Request.Path实现转发到其他路由，此方式在更新到.net6后默认不再可行。 解决 .ne6之后需要修改路由不能使用app.MapControllers()而应该使用app.UseRouting()和app.UseEndpoints(endpoints =&amp;gt; endpoints.MapControllers())。 app.UseMiddleware&amp;lt;RequestPathCheckMiddleware&amp;gt;(); --app.MapControllers(); ++app.UseRouting();... </summary> </entry> <entry><title>在linqpad环境中使用Refit</title><link href="https://dashenxian.github.io/post/%E5%9C%A8linqpad%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8Refit" rel="alternate" type="text/html" title="在linqpad环境中使用Refit" /><published>2024-01-31T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/%E5%9C%A8linqpad%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8Refit</id> <content src="https://dashenxian.github.io/post/%E5%9C%A8linqpad%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8Refit" /> <author> <name>小神仙</name> </author> <category term="refit" /> <category term="linqpad" /> <category term="dotnet" /> <category term="csharp" /> <summary> 在linqpad中使用Refit报错. 问题 在linqpad中使用Refit报错:InvalidOperationException: xxx doesn’t look like a Refit interface. Make sure it has at least one method with a Refit HTTP method attribute and Refit is installed in the project. 解决 nuget引用Castle.Core包 添加一个代理生成类 public class ProxyRestService { static readonly ProxyGenerator Generator = new ProxyGenerator(); public static T For&amp;lt;T&amp;gt;... </summary> </entry> <entry><title>2024-01-16-CityEngine导出glb、gltf设置透明模式</title><link href="https://dashenxian.github.io/post/CityEngine%E5%AF%BC%E5%87%BAglb-gltf%E8%AE%BE%E7%BD%AE%E9%80%8F%E6%98%8E%E6%A8%A1%E5%BC%8F" rel="alternate" type="text/html" title="2024-01-16-CityEngine导出glb、gltf设置透明模式" /><published>2024-01-16T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/CityEngine%E5%AF%BC%E5%87%BAglb-gltf%E8%AE%BE%E7%BD%AE%E9%80%8F%E6%98%8E%E6%A8%A1%E5%BC%8F</id> <content src="https://dashenxian.github.io/post/CityEngine%E5%AF%BC%E5%87%BAglb-gltf%E8%AE%BE%E7%BD%AE%E9%80%8F%E6%98%8E%E6%A8%A1%E5%BC%8F" /> <author> <name>小神仙</name> </author> <category term="cityengine" /> <category term="windows" /> <category term="dotnet" /> <category term="csharp" /> <summary> CityEngine默认导出glb、gltf时是透明的，但是obj不是透明的，在blender中查看会发现glb、gltf模型能透视，如果模型是房子这是不合理的 问题 CityEngine默认导出glb、gltf时是透明的，但是obj不是透明的，在blender中查看会发现glb、gltf模型能透视，如果模型是房子这是不合理的 解决 在cga中有material.opacitymap.mode属性，这个属性对应gltf模型alphaMode属性。material.opacitymap.mode有三个可选值”blend”、”mask” 、 “opaque”，注意必须是小写。在任意cga方法中设置set(material.opacitymap.mode,"opaque")就可以把材质设置为不透明，设置对当前方法作用域有效，即从当前方法开始内部执行的逻辑都会有效，含子方法，... </summary> </entry> <entry><title>Linux系统.net core控制台程序配置目录不对问题</title><link href="https://dashenxian.github.io/post/Linux%E7%B3%BB%E7%BB%9F.net-core%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%AF%B9%E9%97%AE%E9%A2%98" rel="alternate" type="text/html" title="Linux系统.net core控制台程序配置目录不对问题" /><published>2024-01-10T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/Linux%E7%B3%BB%E7%BB%9F.net-core%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%AF%B9%E9%97%AE%E9%A2%98</id> <content src="https://dashenxian.github.io/post/Linux%E7%B3%BB%E7%BB%9F.net-core%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%AF%B9%E9%97%AE%E9%A2%98" /> <author> <name>小神仙</name> </author> <category term="wpf" /> <category term="windows" /> <category term="dotnet" /> <category term="csharp" /> <summary> 在linux中使用dotnet /aaa/bbb/xxx.dll运行程序，如果目录不是dll的目录，会出现无法读取到appsetting.json的情况 问题 在linux中使用dotnet /aaa/bbb/xxx.dll运行程序，如果目录不是dll的目录，会出现无法读取到appsetting.json的情况 解决 builder.ConfigureAppConfiguration((hostingContext, config) =&amp;gt; { var env = hostingContext.HostingEnvironment; ++ config.SetBasePath(_hostingEnvironment.ContentRootPath) config.AddJsonFile("appsetting... </summary> </entry> <entry><title>解决多用户同时远程连接教程</title><link href="https://dashenxian.github.io/post/win10-%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E5%90%8C%E6%97%B6%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%99%E7%A8%8B" rel="alternate" type="text/html" title="解决多用户同时远程连接教程" /><published>2023-12-28T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/win10-%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E5%90%8C%E6%97%B6%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%99%E7%A8%8B</id> <content src="https://dashenxian.github.io/post/win10-%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E5%90%8C%E6%97%B6%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%99%E7%A8%8B" /> <author> <name>小神仙</name> </author> <category term="wpf" /> <category term="windows" /> <category term="dotnet" /> <category term="csharp" /> <summary> 解决多用户同时远程连接，这篇博文基本是按照win10 解决多用户同时远程连接教程（超详细图文）的操作记录，但是关键的地方解决多用户同时远程连接时始终为红色按照原博文操作始终不行，最终按照github上issues的操作才解决，所以记录一下。 开启远程连接开关 打开远程桌面设置开启远程 让win10支持多用户登录 按快捷键 Win+R 输入Gpedit.msc 打开组策略编辑器 点击计算机配置——管理模板——window组件——远程桌面服务——远程桌面会话主机——连接 启用以下三项： 允许用户通过使用远程桌面服务进行远程连接 限制连接的数量设置为最大 将远程桌面服务用户限制到单独的远程桌面服务会话 解决多用户同时远程连接 从https://github.com/SobieskiCodes/RDPWrap下载修改工具，源码就是工具 下载后放... </summary> </entry> <entry><title>SonarQube扫描配置</title><link href="https://dashenxian.github.io/post/SonarQube%E6%89%AB%E6%8F%8F%E9%85%8D%E7%BD%AE" rel="alternate" type="text/html" title="SonarQube扫描配置" /><published>2023-12-27T00:14:08+08:00</published> <id>https://dashenxian.github.io/post/SonarQube%E6%89%AB%E6%8F%8F%E9%85%8D%E7%BD%AE</id> <content src="https://dashenxian.github.io/post/SonarQube%E6%89%AB%E6%8F%8F%E9%85%8D%E7%BD%AE" /> <author> <name>小神仙</name> </author> <category term="SonarQube" /> <category term="windows" /> <category term="dotnet" /> <category term="csharp" /> <summary> SonarQube扫描配置，需要先安装SonarQube服务 配置 在项目目录中增加一个脚本文件scan.ps1,我用的是powershell格式，也可以用bat格式 #安装扫描工具，只有第一次才需要这句 dotnet tool install --global dotnet-sonarscanner dotnet sonarscanner begin /k:"GarendService" /d:sonar.host.url="http://localhost:9000" /d:sonar.login="squ_68c5d637b47414c157289d5555f6a32c06d6fd15" /d:sonar.scm.provider="svn" dotnet build GarendService.sln dotnet sonarscanner end /d:so... </summary> </entry> </feed>
